// SPDX-License-Identifier: MIT

/*
 * This file is part of the Autumn Aggregator Smart Contract
 *
 * This contract provides an user interface to deposit and earn
 * with Provider who is capable of invest the asset to
 * the remote (3rd party) contracts.
 */

pragma solidity ^0.7.3;
pragma experimental ABIEncoderV2;

import "./vendor/Context.sol";
import "./vendor/Operator.sol";
import "./vendor/Rescuable.sol";

import { IConverter } from "./convert/IConverter.sol";
import { IProvider, IProviderInformative } from "./provider/IProvider.sol";

import { FeeManager } from "./FeeManager.sol";
import { AbstractVault } from "./AbstractVault.sol";

contract SimpleVault is
    AbstractVault,
    FeeManager,
    Rescuable
{
    using SafeMath for uint256;
    using SafeERC20 for IERC20;

    constructor(address pool_) {
        pool = pool_;
    }

    // Provider Handlers

    /// @notice the default provider
    IProvider public defaultProvider;

    /// @notice instances of all added providers
    mapping (string /* name */ => IProvider) public providers;

    /// @notice names of all added providers
    string[] public providerNames;

    /// @notice the unused balance of this vault
    /// could be generated by adjustment or provider deletion
    uint256 public unusedPool = 0;

    /// @notice list names of all providers
    function listProviders() external view returns (string[] memory) {
        return providerNames;
    }

    /// @notice query the address of provider by name
    function getProviderAddress(string memory name) external view returns (address) {
        return address(providers[name]);
    }

    /// @notice set the default provider by name
    function setDefaultProvider(string memory name) onlyOperator() external {
        IProvider p = providers[name];
        require(p.IS_PROVIDER(), "SimpleVault: provider not exists");
        defaultProvider = p;
    }

    /// @notice suggest a provider
    function provider() public view returns (IProvider) {
        if (address(defaultProvider) != address(0)) {
            return defaultProvider;
        } else {
            return getProviderAt(0);
        }
    }

    /// @dev get provider by its index
    function getProviderAt(uint256 index) private view returns (IProvider) {
        require(providerNames.length > index, "SimpleVault::getProviderAt: index out of bound");
        return providers[providerNames[index]];
    }

    /// @notice add (or replace) a provider with its name
    function addProvider(string memory name, address provider_) onlyOperator() external {
        IProvider p = IProvider(provider_);
        require(p.IS_PROVIDER(), "SimpleVault: not a provider");
        require(p.tokenToDeposit() == pool, "SimpleVault: variant deposit token");

        (bool exists, ) = searchProviderIndex(name);
        if (!exists) {
            providerNames.push(name);
        }
        providers[name] = p;
    }

    /// @notice search provider index by its name
    function searchProviderIndex(string memory name) public view returns (bool found, uint256 at) {
        for (uint256 i = 0; i < providerNames.length; i++) {
            if (compareString(providerNames[i], name)) {
                return (true, i);
            }
        }
        return (false, 0);
    }

    /// @dev compare the equality of two strings
    function compareString(string memory a, string memory b) private pure returns (bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }

    /// @notice delete provider by its name
    function delProvider(string memory name) onlyOperator() external {
        (bool has, uint256 index) = searchProviderIndex(name);
        if (!has) {
            return;
        }
        withdrawProvider(name, 0);
        removeProvider(name, index);
    }

    /// @notice withdraw funds from a provider, turned to unused
    function withdrawProvider(string memory name, uint256 amount) onlyOperator() public {
        IProvider p = providers[name];
        require(p.IS_PROVIDER(), "SimpleVault: provider not exists");
        amount = amount == 0 ? p.withdrawAll() : p.withdraw(amount);
        unusedPool = unusedPool.add(amount);
        emit ProviderAdjusted(address(p), amount, false);
    }

    /// @notice deposit specific amount of unused balance to a provider
    function depositProvider(string memory name, uint256 unusedAmount) public onlyOperator() {
        IProvider p = providers[name];
        require(p.IS_PROVIDER(), "SimpleVault: provider not exists");
        unusedPool = unusedPool.sub(unusedAmount, "SimpleVault: amount exceeds unused");
        IERC20(pool).safeIncreaseAllowance(address(p), unusedAmount);
        p.deposit(unusedAmount);
        emit ProviderAdjusted(address(p), unusedAmount, true);
    }

    /// @notice emit when pool adjusted by external operator
    event ProviderAdjusted(address indexed provider, uint256 amount, bool deposit);

    /// @dev remove a provider permanently from storage, should withdraw before calling
    function removeProvider(string memory name, uint256 index) private {
        if (address(defaultProvider) == address(providers[name])) {
            defaultProvider = IProvider(address(0));
        }
        providerNames[index] = providerNames[providerNames.length - 1];
        providerNames.pop();
        delete providers[name];
    }

    // Converter

    IConverter public converter; // for convert the reward token to desired token

    function setConverter(address converter_) onlyOperator() external {
        converter = IConverter(converter_);
    }

    /// @dev convert (swap) the reward token back to deposit token
    function convertToken(address from, address to, uint256 amount) private returns (bool success, uint256 got) {
        if (address(converter) == address(0)) {
            return (false, 0);
        }
        IERC20(from).safeIncreaseAllowance(address(converter), amount);
        uint256 before = IERC20(to).balanceOf(address(this));
        (success, ) = converter.proposeConvert(from, to, amount);
        got = IERC20(to).balanceOf(address(this)).sub(before);

        return (success, got);
    }

    // User Storage

    // how much shares the user hold
    mapping (address => uint256) public userShare;

    // how much rewards (for per share) the user cannot claim
    // for example, already claimed or the all accumulated
    // rewards by the time when the user entring
    mapping (address /* user */ => mapping(address /* token */ => uint256)) private userInvalid;

    // User Share Handlers

    /// @notice the total created shares
    uint256 public totalShares;

    /*
     * Share value formula:
     *
     * share per token = total share / total supply
     * share = token * share per token
     *
     * token per share = total supply / total share
     * token = share * token per share
     */

    function getShareByToken(uint256 amount) external view returns (uint256 share) {
        return getShareByTokenWith(amount, totalSupply());
    }

    function getShareByTokenWith(uint256 amount, uint256 totalSupply_) private view returns (uint256 share) {
        if (totalShares == 0) {
            return amount;
        }
        return (amount.mul(totalShares)).div(totalSupply_);
    }

    function getTokenByShare(uint256 share) public view returns (uint256 amount) {
        if (totalShares == 0) {
            return 0;
        }
        return (totalSupply().mul(share)).div(totalShares);
    }

    // IERC20Informative Interface

    function totalSupply() public override view returns (uint256 sum) {
        for (uint256 i = 0; i < providerNames.length; i++) {
            sum = sum.add(balanceProvider(providerNames[i]));
        }
        return unusedPool.add(sum);
    }

    /// @notice get the total balance of provider by name
    function balanceProvider(string memory name) public view returns (uint256) {
        return providers[name].balance();
    }

    function balanceOf(address user) external override view returns (uint256) {
        return getTokenByShare(userShare[user]);
    }

    // Reward Storage

    /// @notice rewarding tokens of this vault
    address[] public rewardTokens;

    /// @notice allocated (unpaid) reward of user that could be claimed at anytime
    mapping (address /* user */ => mapping (address /* token */ => uint256)) public userReward;

    /// @notice the total allocated rewards of all users (for stats)
    mapping (address /* token */ => uint256) public totalReward;

    /// @dev accumulated reward amount of per token (share)
    mapping (address /* token */ => uint256) public rewardPerTokenAccumulated;

    function listRewardTokens() external view returns (address[] memory) {
        return rewardTokens;
    }

    // Externals

    function update() external override {
        for (uint256 i = 0; i < providerNames.length; i++) {
            updateProvider(getProviderAt(i));
        }
    }

    function updateProvider(IProvider p) private {
        updateAndAllocateAll(_msgSender());
        p.update();
    }

    function harvest() external override {
        for (uint256 i = 0; i < providerNames.length; i++) {
            harvestProvider(getProviderAt(i));
        }
    }

    function harvestProvider(IProvider p) public {
        (bool hasReward, address rToken) = updateAndAllocateRewardFor(p, _msgSender());
        if (hasReward) {
            claimAllocatedRewards(rToken, _msgSender());
        }
    }

    function earned(address user, address token) external override view returns (uint256) {
        uint256 available;
        for (uint256 i = 0; i < providerNames.length; i++) {
            available = available.add(
                earnedBy(getProviderAt(i).rewards(), token, userShare[user], userInvalid[user][token])
            );
        }
        return userReward[user][token].add(available);
    }

    // Reward Handlers

    /// @dev calculate new reward amount of per share with known amount of newly added reward
    function rewardPerShareBy(address token, uint256 newReward) private view returns (uint256 rewardPerToken) {
        if (totalShares == 0) {
            return 0;
        }
        return rewardPerTokenAccumulated[token].add(
            newReward
                .mul(1e18)
                .div(totalShares)
        );
    }

    /// @dev calculate and write per share reward, also adding to total reward (for stats)
    function updateRewardPerShareBy(address token, uint256 newReward) private {
        uint256 totalReward_ = totalReward[token];
        totalReward[token] = totalReward_.add(newReward);
        if (totalReward_ == 0) {
            rewardTokens.push(token);
        }
        rewardPerTokenAccumulated[token] = rewardPerShareBy(token, newReward);
    }

    /// @dev calculate available reward for the user by known reward amount
    function earnedBy(uint256 rewardAmount, address rewardToken, uint256 share, uint256 invalidRewardPerShare)
        private view returns (uint256)
    {
        if (rewardAmount == 0 || share == 0) {
            return 0;
        }
        uint256 validPerShare = rewardPerShareBy(rewardToken, rewardAmount).sub(invalidRewardPerShare);
        return share
                .mul(validPerShare)
                .div(1e18);
    }

    function updateAndAllocateAll(address user) private returns (bool hasReward) {
        for (uint256 i = 0; i < providerNames.length; i++) {
            (hasReward, ) = updateAndAllocateRewardFor(getProviderAt(i), user);
            if (hasReward) {
                return true;
            }
        }
        return false;
    }

    /// @dev update per token reward by harvest, and allocate reward for user
    function updateAndAllocateRewardFor(IProvider p, address user) private returns (bool hasReward, address rewardToken) {
        (address rToken, uint256 rAmount) = updateRewardPerTokenByHarvest(p);
        if (rToken == address(0)) {
            return (false, address(0));
        }

        if (rAmount != 0) {
            uint256 userRewards = earnedBy(rAmount, rToken, userShare[user], userInvalid[user][rToken]);
            userReward[user][rToken] = userReward[user][rToken].add(userRewards);
        }

        userInvalid[user][rToken] = rewardPerTokenAccumulated[rToken];
        return (true, rToken);
    }

    /// @dev harvest to get accurated reward amount (and convert to deposit token) then update with it
    function updateRewardPerTokenByHarvest(IProvider p) private returns (address rewardToken, uint256 rewardAmount) {
        if (p.balance() == 0) {
            return (address(0), 0);
        }
        rewardToken = p.tokenToReward();

        uint256 before = IERC20(p.tokenToReward()).balanceOf(address(this));
        p.harvest(); // accurate reward by harvest
        rewardAmount = IERC20(p.tokenToReward()).balanceOf(address(this)).sub(before);
        if (rewardAmount == 0) {
            return (address(0), 0);
        }

        (bool success, uint256 got) = convertToken(p.tokenToReward(), pool, rewardAmount);
        if (success) {
            rewardToken = pool;
            rewardAmount = got;
        }
        rewardAmount = chargeFeeWith("harvest", rewardToken, rewardAmount);
        
        if (success) {
            provider().deposit(rewardAmount); // redeposit to suggested provider
            return (address(0), 0);
        } else {
            updateRewardPerShareBy(rewardToken, rewardAmount);
            return (rewardToken, rewardAmount);
        }
    }

    /// @dev simply claim reward that already allocated for user (without harvest or update)
    function claimAllocatedRewards(address token, address user) private {
        uint256 allocated = userReward[user][token];
        if (allocated == 0) {
            return;
        }
        userReward[user][token] = 0;
        IERC20(token).safeTransfer(user, allocated);
    }

    // Deposit Event Handlers

    function afterTokenTransferredIn(uint256 amount) internal override {
        // invalidate all previously accumulated rewards
        updateAndAllocateAll(_msgSender());
        uint256 supplyBefore = totalSupply();

        IProvider p = provider();
        IERC20(pool).safeIncreaseAllowance(address(p), amount);
        amount = p.deposit(amount);

        uint256 share = getShareByTokenWith(amount, supplyBefore);
        userShare[_msgSender()] = userShare[_msgSender()].add(share);
        totalShares = totalShares.add(share);
    }

    // Withdraw Event Handlers

    function beforeTokenTransferOut(uint256 share) internal override returns (uint256 actualAmount) {
        updateAndAllocateAll(_msgSender());
        
        userShare[_msgSender()] = userShare[_msgSender()].sub(share, "SimpleVault: amount exceeds the share");
        uint256 amount = getTokenByShare(share);
        totalShares = totalShares.sub(share);

        amount = collectWithdraw(amount);
        amount = chargeFeeWith("withdraw", pool, amount);

        return amount;
    }

    /// @dev collect withdraw asset from providers to vault
    function collectWithdraw(uint256 amount) private returns (uint256 actualAmount) {
        // Try withdraw from unused pool
        if (unusedPool != 0) {
            if (unusedPool >= amount) {
                unusedPool = unusedPool.sub(amount);
                return amount;
            } else {
                unusedPool = 0;
                amount = amount.sub(unusedPool);
            }
        }

        // Try withdraw from providers
        IProvider p = provider();
        if (p.balance() >= amount) {
            return p.withdraw(amount);
        }

        uint256 remaining = amount;
        for (uint256 i = 0; i < providerNames.length; i++) {
            p = getProviderAt(i);

            if (p.balance() >= remaining) {
                return actualAmount.add(p.withdraw(remaining));
            } else {
                remaining = remaining.sub(p.balance());
                actualAmount = actualAmount.add(p.withdrawAll());
            }
        }
    }
}